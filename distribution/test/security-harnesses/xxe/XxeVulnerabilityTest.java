/*
 * Copyright (c) Codice Foundation
 * <p>
 * This is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 * <p>
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details. A copy of the GNU Lesser General Public License
 * is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 */
package org.codice.alliance.test.security.harness.xxe;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.regex.Pattern;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import org.codice.alliance.test.security.harness.common.SecurityTestBase;
import org.codice.alliance.test.security.harness.common.VulnerabilityTestUtils;
import org.junit.Ignore;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

/**
 * Security test harness for XXE (XML External Entity) vulnerabilities.
 *
 * <p>This test harness demonstrates XXE vulnerabilities in XML parsing across Alliance components.
 * XXE attacks exploit XML parsers that process external entity references, allowing attackers to:
 *
 * <ul>
 *   <li>Read arbitrary files from the filesystem
 *   <li>Perform SSRF (Server-Side Request Forgery) attacks
 *   <li>Cause denial of service via entity expansion (XML bombs)
 *   <li>Exfiltrate data to external systems
 * </ul>
 *
 * <p><strong>DO-278 Test-First Approach:</strong>
 *
 * <p>These tests are designed to FAIL initially, demonstrating that XXE vulnerabilities exist in
 * the current codebase. Once security fixes are implemented (proper XML parser configuration), the
 * tests should be updated to verify the fixes prevent exploitation.
 *
 * <p><strong>CVE References:</strong>
 *
 * <p>XXE vulnerabilities are common in XML-processing applications. Related CVEs include:
 *
 * <ul>
 *   <li>CVE-2021-44228 (Log4Shell - includes XXE component)
 *   <li>CVE-2019-12384 (Jackson XML - XXE)
 *   <li>CVE-2018-1000840 (dom4j - XXE)
 * </ul>
 *
 * <p><strong>OWASP Classification:</strong> A05:2021 â€“ Security Misconfiguration
 *
 * <p><strong>Remediation:</strong>
 *
 * <p>To fix XXE vulnerabilities, configure XML parsers to disable external entity processing:
 *
 * <pre>{@code
 * DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
 * factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
 * factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
 * factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
 * factory.setExpandEntityReferences(false);
 * }</pre>
 *
 * @see SecurityTestBase for base test infrastructure
 * @see VulnerabilityTestUtils for payload generation
 */
public class XxeVulnerabilityTest extends SecurityTestBase {

  private static final Logger LOGGER = LoggerFactory.getLogger(XxeVulnerabilityTest.class);

  /** Pattern to detect /etc/passwd content (Unix/Linux systems). */
  private static final Pattern PASSWD_PATTERN = Pattern.compile("root:x?:0:0:");

  /** Pattern to detect Windows system file content. */
  private static final Pattern WINDOWS_SYSTEM_PATTERN = Pattern.compile("\\[boot loader\\]");

  /**
   * Tests basic XXE file disclosure vulnerability on Unix/Linux systems.
   *
   * <p>This test attempts to read /etc/passwd using an external entity reference. On vulnerable
   * systems, the file content will be included in the parsed XML document.
   *
   * <p><strong>Expected Initial Result:</strong> FAIL - Vulnerability exists
   *
   * <p><strong>Expected After Fix:</strong> Exception thrown or empty result
   */
  @Test
  @SecurityTest(description = "XXE file disclosure - /etc/passwd", severity = "CRITICAL")
  @OWASP(category = "A05:2021-Security Misconfiguration")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeFileDisclosureEtcPasswd() throws Exception {
    LOGGER.info("Testing XXE file disclosure: /etc/passwd");

    // Arrange: Create XXE payload targeting /etc/passwd
    String xxePayload = VulnerabilityTestUtils.createXxePayload("file:///etc/passwd");

    // Act: Parse XML with unsafe parser (simulating vulnerable code)
    DocumentBuilder unsafeParser = createUnsafeXmlParser();
    Document document = parseXml(xxePayload, unsafeParser);
    String parsedContent = document.getDocumentElement().getTextContent();

    LOGGER.debug("Parsed content: {}", parsedContent);

    // Assert: Verify external entity was resolved (vulnerability exists)
    assertVulnerabilityExists(parsedContent, PASSWD_PATTERN);
  }

  /**
   * Tests XXE file disclosure vulnerability on Windows systems.
   *
   * <p>This test attempts to read C:\boot.ini using an external entity reference.
   */
  @Test
  @SecurityTest(description = "XXE file disclosure - Windows boot.ini", severity = "CRITICAL")
  @OWASP(category = "A05:2021-Security Misconfiguration")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeFileDisclosureWindowsBootIni() throws Exception {
    LOGGER.info("Testing XXE file disclosure: Windows boot.ini");

    // Arrange: Create XXE payload targeting Windows system file
    String xxePayload = VulnerabilityTestUtils.createXxePayload("file:///C:/boot.ini");

    // Act: Parse XML with unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();
    Document document = parseXml(xxePayload, unsafeParser);
    String parsedContent = document.getDocumentElement().getTextContent();

    LOGGER.debug("Parsed content: {}", parsedContent);

    // Assert: Verify external entity was resolved
    // Note: This will only work on Windows systems with boot.ini
    assertThat("Document should be parsed", document, is(notNullValue()));
  }

  /**
   * Tests XXE vulnerability with parameter entities.
   *
   * <p>Parameter entities (%entity;) can be used for more advanced XXE attacks and may bypass some
   * protections.
   */
  @Test
  @SecurityTest(description = "XXE with parameter entities", severity = "CRITICAL")
  @OWASP(category = "A05:2021-Security Misconfiguration")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeParameterEntity() throws Exception {
    LOGGER.info("Testing XXE with parameter entities");

    // Arrange: Create parameter entity XXE payload
    String xxePayload = VulnerabilityTestUtils.createXxeParameterEntityPayload("file:///etc/passwd");

    // Act: Parse XML with unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();

    try {
      Document document = parseXml(xxePayload, unsafeParser);
      String parsedContent = document.getDocumentElement().getTextContent();

      LOGGER.debug("Parsed content: {}", parsedContent);

      // Assert: Verify parameter entity processing occurred
      assertThat("Document should be parsed", document, is(notNullValue()));
    } catch (SAXException e) {
      LOGGER.info("Parser rejected parameter entity (may indicate partial protection)");
      // Some parsers may reject parameter entities even with unsafe configuration
    }
  }

  /**
   * Tests SSRF (Server-Side Request Forgery) via XXE.
   *
   * <p>XXE can be used to make the server perform HTTP requests to arbitrary URLs, enabling SSRF
   * attacks against internal services.
   */
  @Test
  @SecurityTest(description = "SSRF via XXE - internal service access", severity = "CRITICAL")
  @OWASP(category = "A10:2021-Server-Side Request Forgery")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeSsrfInternalService() throws Exception {
    LOGGER.info("Testing SSRF via XXE: localhost service");

    // Arrange: Create SSRF payload targeting localhost
    String xxePayload = VulnerabilityTestUtils.createXxeSsrfPayload("http://localhost:8080/admin");

    // Act: Parse XML with unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();

    try {
      Document document = parseXml(xxePayload, unsafeParser);
      String parsedContent = document.getDocumentElement().getTextContent();

      LOGGER.debug("Parsed content: {}", parsedContent);

      // Assert: If we got content, SSRF succeeded
      assertThat("Document should be parsed", document, is(notNullValue()));

      // Log for analysis - content may contain response from internal service
      if (parsedContent != null && !parsedContent.isEmpty()) {
        LOGGER.warn("SSRF may have succeeded - received content from internal URL");
      }
    } catch (SAXException | IOException e) {
      LOGGER.info("SSRF attempt may have been blocked: {}", e.getMessage());
    }
  }

  /**
   * Tests SSRF via XXE targeting AWS metadata service.
   *
   * <p>In cloud environments, XXE can be used to access instance metadata containing sensitive
   * information like IAM credentials.
   */
  @Test
  @SecurityTest(description = "SSRF via XXE - AWS metadata service", severity = "CRITICAL")
  @OWASP(category = "A10:2021-Server-Side Request Forgery")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeSsrfAwsMetadata() throws Exception {
    LOGGER.info("Testing SSRF via XXE: AWS metadata service");

    // Arrange: Create SSRF payload targeting AWS metadata
    String xxePayload = VulnerabilityTestUtils.createXxeSsrfPayload(
        VulnerabilityTestUtils.createSsrfAwsMetadata());

    // Act: Parse XML with unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();

    try {
      Document document = parseXml(xxePayload, unsafeParser);
      String parsedContent = document.getDocumentElement().getTextContent();

      LOGGER.debug("Parsed content: {}", parsedContent);

      // Assert: Check if metadata was accessed
      assertThat("Document should be parsed", document, is(notNullValue()));

      if (parsedContent != null && parsedContent.contains("ami-")) {
        LOGGER.error("CRITICAL: AWS metadata was accessed via XXE!");
        assertVulnerabilityExists(parsedContent, "ami-");
      }
    } catch (SAXException | IOException e) {
      LOGGER.info("AWS metadata access blocked: {}", e.getMessage());
    }
  }

  /**
   * Tests Billion Laughs XML bomb attack.
   *
   * <p>This denial-of-service attack uses nested entity expansion to consume excessive memory. A
   * small XML document expands to gigabytes in memory.
   *
   * <p><strong>WARNING:</strong> This test may cause memory exhaustion. The test timeout will
   * prevent complete system failure.
   */
  @Test
  @SecurityTest(description = "Billion Laughs XML bomb DoS", severity = "HIGH")
  @OWASP(category = "A05:2021-Security Misconfiguration")
  @Ignore("Test demonstrates vulnerability - may cause OOM - remove @Ignore carefully")
  public void testBillionLaughsXmlBomb() throws Exception {
    LOGGER.info("Testing Billion Laughs XML bomb");
    LOGGER.warn("This test may consume significant memory");

    // Arrange: Create billion laughs payload
    String xmlBomb = VulnerabilityTestUtils.createBillionLaughsAttack();

    // Act: Attempt to parse XML bomb
    DocumentBuilder unsafeParser = createUnsafeXmlParser();
    long startMemory = Runtime.getRuntime().freeMemory();

    try {
      Document document = parseXml(xmlBomb, unsafeParser);
      String content = document.getDocumentElement().getTextContent();

      long endMemory = Runtime.getRuntime().freeMemory();
      long memoryConsumed = startMemory - endMemory;

      LOGGER.warn("Memory consumed: {} bytes", memoryConsumed);
      LOGGER.warn("Content length: {} characters", content.length());

      // Assert: If parsing succeeded without error, vulnerability exists
      assertThat("Billion Laughs attack should cause issues", content.length() > 1000000, is(true));

    } catch (OutOfMemoryError e) {
      LOGGER.error("OutOfMemoryError occurred - Billion Laughs attack succeeded");
      throw e;
    } catch (Exception e) {
      LOGGER.info("Billion Laughs attack blocked: {}", e.getMessage());
    }
  }

  /**
   * Tests quadratic blowup XML attack.
   *
   * <p>This is an alternative entity expansion attack that may bypass some Billion Laughs
   * protections.
   */
  @Test
  @SecurityTest(description = "Quadratic blowup XML bomb DoS", severity = "HIGH")
  @OWASP(category = "A05:2021-Security Misconfiguration")
  @Ignore("Test demonstrates vulnerability - may cause performance issues")
  public void testQuadraticBlowupXmlBomb() throws Exception {
    LOGGER.info("Testing quadratic blowup XML bomb");

    // Arrange: Create quadratic blowup payload
    String xmlBomb = VulnerabilityTestUtils.createQuadraticBlowupAttack(10000, 10000);

    // Act: Attempt to parse
    DocumentBuilder unsafeParser = createUnsafeXmlParser();
    long startTime = System.currentTimeMillis();

    try {
      Document document = parseXml(xmlBomb, unsafeParser);
      String content = document.getDocumentElement().getTextContent();

      long endTime = System.currentTimeMillis();
      long duration = endTime - startTime;

      LOGGER.warn("Parse duration: {} ms", duration);
      LOGGER.warn("Content length: {} characters", content.length());

      // Assert: Excessive processing time or memory indicates vulnerability
      assertThat("Quadratic blowup should cause processing delay", duration > 1000, is(true));

    } catch (Exception e) {
      LOGGER.info("Quadratic blowup attack blocked: {}", e.getMessage());
    }
  }

  /**
   * Tests XXE with data exfiltration via error messages.
   *
   * <p>Even when direct entity resolution fails, error messages may leak file contents.
   */
  @Test
  @SecurityTest(description = "XXE data exfiltration via error messages", severity = "HIGH")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeErrorBasedExfiltration() throws Exception {
    LOGGER.info("Testing XXE error-based data exfiltration");

    // Arrange: Create XXE payload that triggers error with file content
    String xxePayload =
        "<?xml version=\"1.0\"?>\n"
            + "<!DOCTYPE foo [\n"
            + "  <!ENTITY % file SYSTEM \"file:///etc/passwd\">\n"
            + "  <!ENTITY % error \"<!ENTITY &#x25; exfil SYSTEM 'file:///nonexistent/%file;'>\">\n"
            + "  %error;\n"
            + "  %exfil;\n"
            + "]>\n"
            + "<foo>test</foo>";

    // Act: Parse with unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();

    try {
      parseXml(xxePayload, unsafeParser);
    } catch (SAXException e) {
      String errorMessage = e.getMessage();
      LOGGER.debug("Error message: {}", errorMessage);

      // Assert: Check if error message contains file content
      if (errorMessage != null && PASSWD_PATTERN.matcher(errorMessage).find()) {
        LOGGER.error("File content leaked via error message!");
        assertVulnerabilityExists(errorMessage, PASSWD_PATTERN);
      }
    }
  }

  /**
   * Tests that safe XML parser configuration prevents XXE.
   *
   * <p>This test verifies that properly configured XML parsers reject XXE attacks.
   *
   * <p><strong>Expected Result:</strong> PASS - Safe configuration blocks XXE
   */
  @Test
  @SecurityTest(description = "Verify safe XML parser blocks XXE", expectVulnerability = false)
  public void testSafeParserBlocksXxe() throws Exception {
    LOGGER.info("Testing safe XML parser configuration");

    // Arrange: Create XXE payload
    String xxePayload = VulnerabilityTestUtils.createXxePayload("file:///etc/passwd");

    // Act: Parse with safe parser configuration
    DocumentBuilder safeParser = createSafeXmlParser();

    try {
      Document document = parseXml(xxePayload, safeParser);
      String parsedContent = document.getDocumentElement().getTextContent();

      LOGGER.debug("Parsed content: {}", parsedContent);

      // Assert: External entity should NOT be resolved
      assertVulnerabilityFixed(parsedContent, PASSWD_PATTERN);
      assertThat("Content should be empty or not contain file data",
          parsedContent == null || parsedContent.isEmpty() || !PASSWD_PATTERN.matcher(parsedContent).find(),
          is(true));

    } catch (SAXException e) {
      // Exception is acceptable - indicates parser rejected malicious input
      LOGGER.info("Safe parser correctly rejected XXE: {}", e.getMessage());
      assertThat("Exception message should indicate DOCTYPE/entity rejection",
          e.getMessage(),
          containsString("DOCTYPE"));
    }
  }

  /**
   * Tests XXE vulnerability with file:// URI targeting sensitive Alliance configuration.
   *
   * <p>This test targets Alliance-specific configuration files that may contain sensitive data.
   */
  @Test
  @SecurityTest(description = "XXE targeting Alliance configuration files", severity = "CRITICAL")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeAllianceConfigFile() throws Exception {
    LOGGER.info("Testing XXE targeting Alliance configuration");

    // Arrange: Create temporary config file simulating Alliance configuration
    File tempConfig = createTempFile("alliance-config", ".xml");
    String sensitiveData = "<config><apiKey>SECRET_KEY_12345</apiKey></config>";
    Files.write(tempConfig.toPath(), sensitiveData.getBytes(StandardCharsets.UTF_8));

    String xxePayload = VulnerabilityTestUtils.createXxePayload("file://" + tempConfig.getAbsolutePath());

    // Act: Parse with unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();
    Document document = parseXml(xxePayload, unsafeParser);
    String parsedContent = document.getDocumentElement().getTextContent();

    LOGGER.debug("Parsed content: {}", parsedContent);

    // Assert: Verify configuration data was leaked
    assertVulnerabilityExists(parsedContent, "SECRET_KEY_12345");
  }

  /**
   * Tests XXE with jar:// protocol for attacking Java applications.
   *
   * <p>The jar:// protocol can be abused to read files from JAR archives, potentially exposing
   * embedded resources.
   */
  @Test
  @SecurityTest(description = "XXE with jar:// protocol", severity = "HIGH")
  @Ignore("Test demonstrates vulnerability - remove @Ignore to verify fix")
  public void testXxeJarProtocol() throws Exception {
    LOGGER.info("Testing XXE with jar:// protocol");

    // Arrange: Create XXE payload with jar:// URI
    // This targets a file inside a JAR (simulated)
    String xxePayload =
        "<?xml version=\"1.0\"?>\n"
            + "<!DOCTYPE foo [\n"
            + "  <!ENTITY xxe SYSTEM \"jar:file:///path/to/app.jar!/META-INF/MANIFEST.MF\">\n"
            + "]>\n"
            + "<root><data>&xxe;</data></root>";

    // Act: Parse with unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();

    try {
      Document document = parseXml(xxePayload, unsafeParser);
      String parsedContent = document.getDocumentElement().getTextContent();

      LOGGER.debug("Parsed content: {}", parsedContent);

      // Assert: Check if JAR content was accessed
      assertThat("Document should be parsed", document, is(notNullValue()));

    } catch (SAXException | IOException e) {
      LOGGER.info("jar:// protocol access blocked: {}", e.getMessage());
    }
  }

  /**
   * Benchmark test to measure XXE parsing performance impact.
   *
   * <p>This test measures the performance difference between safe and unsafe parsing to demonstrate
   * that security fixes don't significantly impact performance.
   */
  @Test
  public void testXxeParsingPerformanceBenchmark() throws Exception {
    LOGGER.info("Benchmarking XXE parsing performance");

    String normalXml = "<?xml version=\"1.0\"?><root><data>Normal content</data></root>";

    // Benchmark unsafe parser
    DocumentBuilder unsafeParser = createUnsafeXmlParser();
    long unsafeStart = System.nanoTime();
    for (int i = 0; i < 1000; i++) {
      parseXml(normalXml, unsafeParser);
    }
    long unsafeDuration = System.nanoTime() - unsafeStart;

    // Benchmark safe parser
    DocumentBuilder safeParser = createSafeXmlParser();
    long safeStart = System.nanoTime();
    for (int i = 0; i < 1000; i++) {
      parseXml(normalXml, safeParser);
    }
    long safeDuration = System.nanoTime() - safeStart;

    LOGGER.info("Unsafe parser: {} ns", unsafeDuration);
    LOGGER.info("Safe parser: {} ns", safeDuration);
    LOGGER.info("Performance overhead: {}%",
        ((safeDuration - unsafeDuration) * 100.0 / unsafeDuration));

    // Safe parser should not be significantly slower (allow 50% overhead)
    assertThat("Safe parser performance should be acceptable",
        safeDuration < unsafeDuration * 1.5,
        is(true));
  }
}
